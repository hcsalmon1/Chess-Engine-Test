I had to change the algorithm with java. Instead of the standard rook and bishop move generation, I split 
them up into direction and then get each direction individually. This is slower but stops me needing a 54x4096 and
64x512 array. This is a problem because ulongs are not directly supported in java.

You have two choices
1. convert all the constants to minus, if they are over the max signed long value, and risk a lot of bugs and testing that way.
2. convert all the constants to BigIntegers like this:
     static final long  MAX_ULONG =  = 18446744073709551615;
This means replacing all values with this type in all constants. You also need to use OOP for everything.
This:
    BigInteger bitboard = bitboard1 & bitboard2;
Turns into:
    BigInteger bitboard = bitboard1.and(bitboard2);

I chose the second approach and tried converting everything over to this. I created so many bugs that I couldn't fix and 
gave up in the end.
